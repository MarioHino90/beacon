/**
 * @fileoverview these types are used to extract typescript type definitions for translations,
 * and manipulate namespace/translation key/translation type values in order to
 * support the API for `useI18nNamespace`, `mergeTranslations`
 */
export declare type NamespaceKeys<TranslationMap> = keyof TranslationMap & Exclude<string, MergeString<string, string>>;
/**
 * get the keys of the children of a translation map from its namespace
 *
 * This is used to extract the translation keys of a namespace:
 * type T = {
 *   ns: {
 *     key1: never;
 *     key2: { argumentname: string }
 *   }
 * }
 *
 * TranslationKeys<T, "ns"> = "key1" | "key2"
 */
export declare type TranslationKeys<TranslationMap, N extends keyof TranslationMap = keyof TranslationMap> = {
    [K in N]: keyof TranslationMap[K] & Exclude<string, MergeString<string, string>>;
}[N];
/**
 * Extract a list of namespace keys that contain translation keys with arguments.
 *
 * A translation with arguments is one that contains interpolated arguments like "Hello { place }"
 * In this example translation "place" is an argument, and the type would be:
 * {
 *   ns: {
 *     key: { place: string };
 *   }
 * }
 *
 * A translation without interpolated arguments like "Hello Greg" has a type like:
 *
 * {
 *   ns: {
 *     key: never;
 *   }
 * }
 *
 * Thus "TranslationMap[T][K] extends never" is testing whether TranslationMap[T][K] has no arguments
 *
 * If it extends never, then it has no arguments
 *
 * Ohterwise, we get the namespace key(s) (like "ns") back.
 */
export declare type NamespaceKeysWithArguments<TranslationMap, N extends NamespaceKeys<TranslationMap> = NamespaceKeys<TranslationMap>> = {
    [T in N]: {
        [K in TranslationKeys<TranslationMap, T>]: TranslationMap[T][K] extends never ? never : T;
    }[TranslationKeys<TranslationMap, T>];
}[N];
/**
 * The inverse of NamespaceKeysWithArguments
 */
export declare type NamespaceKeysWithoutArguments<TranslationMap, N extends NamespaceKeys<TranslationMap> = NamespaceKeys<TranslationMap>> = {
    [T in N]: {
        [K in TranslationKeys<TranslationMap, T>]: TranslationMap[T][K] extends never ? T : never;
    }[TranslationKeys<TranslationMap, T>];
}[N];
/**
 * Drilling down one level further, this is getting the translation keys with arguments
 * {
 *   ns: {
 *     key: { place: string };
 *     noargs: never;
 *   }
 * }
 *
 * In this example, we will get back "key"
 */
export declare type TranslationKeysWithArguments<TranslationMap, N extends NamespaceKeys<TranslationMap>> = {
    [T in N]: {
        [K in TranslationKeys<TranslationMap, T>]: TranslationMap[T][K] extends never ? never : K;
    }[TranslationKeys<TranslationMap, T>];
}[N];
/**
 * The inverse of TranslationKeysWithArguments
 * {
 *   ns: {
 *     key: { place: string };
 *     noargs: never;
 *   }
 * }
 *
 * In this example, we will get back "noargs"
 */
export declare type TranslationKeysWithoutArguments<TranslationMap, N extends NamespaceKeys<TranslationMap>> = {
    [T in N]: {
        [K in TranslationKeys<TranslationMap, T>]: TranslationMap[T][K] extends never ? K : never;
    }[TranslationKeys<TranslationMap, T>];
}[N];
/**
 * combine two constant strings into a dotted string
 * {
 *   ns: {
 *     key: { place: string };
 *   }
 * }
 *
 * In this example, "ns" and "key" are combined to "ns.key"
 */
export declare type MergeString<A, B> = A extends string ? B extends string ? `${A}.${B}` : never : never;
/**
 * Coerce typescript into recognizing that a key is in fact a key when it is confused
 */
export declare type CoerceKeyof<O, T> = T extends keyof O ? T : never;
/**
 * The namespace-aware "t" function for translating from an i18n key and default value to a translated string
 */
export interface TranslateFunction<TranslationMap, Namespace extends NamespaceKeys<TranslationMap>> {
    (key: NamespaceKeysWithoutArguments<TranslationMap, Namespace>, defaultValue: string): string;
    <Secondary extends NamespaceKeysWithArguments<TranslationMap, Namespace>>(key: TranslationKeysWithArguments<TranslationMap, Namespace>, defaultValue: string, options: TranslationMap[Namespace][CoerceKeyof<TranslationMap[Namespace], Secondary>]): string;
}
/**
 * The namespace-aware "k" function for getting a key to pass to <Trans i18nKey="<here>">
 */
export declare type KeyFunction<TranslationMap, Namespace extends NamespaceKeys<TranslationMap>> = (key: TranslationKeys<TranslationMap, Namespace>) => string;
/**
 * This is used to validate the shape of translations. Because statically imported JSON
 * does not have index signatures, we can't use the more idiomatic:
 *
 * ```
 * type Translations = {
 *   [locale: string]: {
 *     braze: {
 *       [namespace: string]: {
 *         [translation: string]: string;
 *       }
 *     }
 *   }
 * }
 * ```
 *
 * This is the next-best thing (and maybe better, because we have error messages).
 *
 * Use like:
 *
 * const funcThatUsesTranslations = <T>(translations: Translations<T>) => {...}
 *
 * It will return the type unchanged if it has the right shape, and otherwise tell you where the error lies
 */
export declare type Translations<T> = T extends infer A ? A extends number | string ? "missing locale keys" : A extends {
    [P in keyof A]: {
        braze: infer B;
    };
} ? B extends {
    [Namespace in keyof B]: infer D;
} ? D extends {
    [TranslationKey in keyof D]: string;
} ? A : B extends string | number ? "missing namespaces" : "translations must be strings" : "missing namespaces" : "missing braze namespace" : "missing locale keys";
