"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.syncToTranslationRepo = exports.addChanges = exports.checkForTranslationChanges = exports.checkIfDirty = exports.buildSyncFiles = exports.removeMainLocaleFiles = exports.validateArgs = exports.getValidationError = exports.validateTranslationRepoPathsConfig = exports.validateTranslationRepoConfig = void 0;
const chalk_1 = require("chalk");
const execa_1 = __importDefault(require("execa"));
const path_1 = __importDefault(require("path"));
const process_1 = __importDefault(require("process"));
const fs_1 = require("fs");
const config_node_1 = require("../config-node");
const utils_1 = require("./utils");
/**
 * validates that the translationRepo configuration option is valid
 *
 *
 * @param translationRepo the current configuration option
 * @param getError function to get error string
 *
 * @throws if config is not valid
 */
const validateTranslationRepoConfig = (translationRepo, getError) => {
    const getTranslationRepoValidationText = () => getError("translationRepo", utils_1.ArgType.cli);
    (0, utils_1.checkStringConfig)(translationRepo, getTranslationRepoValidationText);
};
exports.validateTranslationRepoConfig = validateTranslationRepoConfig;
/**
 * validates that the translationRepoPaths configuration option is valid
 *
 * @param translationRepoPaths the current configuration option
 * @param getError function to get error string
 *
 * @throws if config is not valid
 */
const validateTranslationRepoPathsConfig = (translationRepoPaths, getError) => {
    const getTranslationRepoPathsValidationText = () => getError("translationRepoPaths", utils_1.ArgType.config);
    // this does not need the inside items verified because it's verified by
    // the config fetch if exists and CANNOT be passed as a command line argument
    (0, utils_1.checkArrayConfig)(translationRepoPaths, getTranslationRepoPathsValidationText);
};
exports.validateTranslationRepoPathsConfig = validateTranslationRepoPathsConfig;
/**
 * gets error text for configuration validation error
 *
 * @param err the raised error
 */
const getValidationError = (err) => err.message;
exports.getValidationError = getValidationError;
/**
 * validates that all of the configuration options are valid
 *
 * Exits process if checks fail
 *
 * @param config the current configuration options
 * @param getError function to get error string
 */
const validateArgs = async (config, getError) => await (0, utils_1.addErrorHandler)(() => {
    const { translationRepo, translationRepoPaths } = config;
    (0, exports.validateTranslationRepoConfig)(translationRepo, getError);
    (0, exports.validateTranslationRepoPathsConfig)(translationRepoPaths, getError);
}, exports.getValidationError)();
exports.validateArgs = validateArgs;
/**
 * removes all "old-version" files for the main locale
 *
 * @param path the folder to remove files from
 * @param mainLocale the locale to remove "old-version" files of (default: "en")
 */
const removeMainLocaleFiles = async (path, mainLocale = "en") => {
    const deleteFiles = await (0, utils_1.globp)(`**/*.${mainLocale}.braze.json`, {
        cwd: path,
    });
    await Promise.all(deleteFiles.map(async (file) => await fs_1.promises.rm(`${path}/${file}`)));
};
exports.removeMainLocaleFiles = removeMainLocaleFiles;
/**
 * copies files from the dev directory to the translation directory
 *
 * @param langs list of languages to sync
 * @param secondaryLangs list of languages to clean after sync
 * @param repoPath a link between a dev folder and a translation folder
 */
const buildSyncFiles = (langs, secondaryLangs) => async (repoPath) => {
    const { dev, translations } = repoPath;
    const translationsPath = path_1.default.resolve(translations);
    await (0, exports.removeMainLocaleFiles)(translationsPath);
    const files = await (0, utils_1.syncDirectoryFiles)(dev, translationsPath, langs);
    await (0, utils_1.cleanLocaleFiles)(path_1.default.resolve(dev), translationsPath, secondaryLangs);
    return files;
};
exports.buildSyncFiles = buildSyncFiles;
/**
 * check if there are any git changes and throw error if so
 */
const checkIfDirty = async () => {
    const isDirty = await (0, utils_1.checkIfGitChanges)();
    if (isDirty) {
        (0, utils_1.handleError)("Please stash or commit your changes in the Translation repo");
    }
};
exports.checkIfDirty = checkIfDirty;
/**
 * check if the process of copying files caused changes - exits process if no
 * changes are found
 *
 * @param cleanTranslationBranches callback function to clean git repo on no changes found
 */
const checkForTranslationChanges = async (cleanTranslationBranches) => {
    // check if there were actually changes
    const hasChanges = await (0, utils_1.checkIfGitChanges)();
    if (hasChanges) {
        console.log((0, chalk_1.greenBright)("Files Copied To Translation Repo!"));
    }
    else {
        console.log((0, chalk_1.yellowBright)("No Translation Changes Found. Exiting..."));
        await cleanTranslationBranches();
        process_1.default.exit();
    }
};
exports.checkForTranslationChanges = checkForTranslationChanges;
/**
 * Commits changes to git and pushes the branch
 *
 * @param cleanTranslationBranches callback to clean branches on error
 * @param branchName name of the current branch
 */
const addChanges = async (cleanTranslationBranches, branchName) => await (0, utils_1.addErrorHandler)(async () => {
    await execa_1.default.command("git add .");
    await (0, execa_1.default)("git", [
        "commit",
        "-m",
        `chore:\ sync\ translation\ files\ from\ development\n`,
    ]);
    await execa_1.default.command(`git push --set-upstream origin ${branchName}`);
}, (err) => `Could not sync translation files: ${err}`, cleanTranslationBranches)();
exports.addChanges = addChanges;
/**
 * handles syncing translations from the development repo to the
 * translation repo
 *
 * @param args the command line arguements
 * @param configPath the file path to the config file
 */
const syncToTranslationRepo = async (args, configPath) => {
    const config = (0, config_node_1.loadConfig)(configPath);
    const { translationRepo = "" } = args;
    const translationRepoPaths = config.get("translationRepoPaths");
    const langs = config.get("translationSyncLanguages");
    const secondaryLangs = config.get("devSyncLanguages");
    await (0, exports.validateArgs)({ ...args, translationRepoPaths }, (0, utils_1.getConfigurationError)(configPath));
    // create branch and push
    const mainBranch = "main";
    const branchName = `translation-sync-${process_1.default.pid}`;
    process_1.default.chdir(translationRepo);
    await (0, exports.checkIfDirty)();
    await (0, utils_1.checkoutBranch)(branchName, mainBranch);
    const cleanTranslationBranches = async () => await (0, utils_1.cleanBranches)(branchName, mainBranch);
    // copy files to translation path
    const syncFiles = (0, exports.buildSyncFiles)(langs, secondaryLangs);
    const fileSyncs = translationRepoPaths.map((repoPath) => syncFiles(repoPath));
    await Promise.all(fileSyncs);
    // check if there were actually changes
    await (0, exports.checkForTranslationChanges)(cleanTranslationBranches);
    // if there were changes, commit and push them
    await (0, exports.addChanges)(async () => await (0, utils_1.cleanBranchesOnError)(branchName, mainBranch, translationRepoPaths.map(({ translations }) => translations)), branchName);
    // cleanup
    await cleanTranslationBranches();
    console.log((0, chalk_1.greenBright)(`Go to https://github.com/braze-inc/translations/pull/new/${branchName} to open a new PR`));
};
exports.syncToTranslationRepo = syncToTranslationRepo;
exports.default = exports.syncToTranslationRepo;
//# sourceMappingURL=sync-to-translation.js.map