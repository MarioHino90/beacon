"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.cleanLocaleFiles = exports.buildDeleteExtraKeys = exports.buildDeleteExtraFiles = exports.getDeletionSecondaryFiles = exports.syncDirectoryFiles = exports.mergeFiles = exports.buildMergeFile = exports.writeTranslationToFile = exports.copyFiles = exports.getSyncRegex = void 0;
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const deepMerge_1 = require("../../utils/deepMerge");
const sortMergedTranslations_1 = require("../../utils/sortMergedTranslations");
const fileUtils_1 = require("./fileUtils");
const handleError_1 = require("./handleError");
/**
 * gets the regex for which files to copy
 *
 * @param langs which languages to pull - if none are set, all will be fetched
 *
 * @returns the regex for which files to copy as string
 */
const getSyncRegex = (langs) => {
    if (!langs.length) {
        return "**/*.braze.json";
    }
    return `**/*.@(${langs.join("|")}).braze.json`;
};
exports.getSyncRegex = getSyncRegex;
/**
 * copies all translation json files that do not currently exist
 *
 * @param srcPath directory to copy from
 * @param destPath directory to copy to
 * @param srcFiles the files to copy from
 * @param destFiles the files that currently exist in the destination directory
 *
 * @returns a promise that resolves when copying is finished
 */
const copyFiles = async (srcPath, destPath, srcFiles, destFiles) => {
    // should copy all files that don't currently exist
    const copyFiles = srcFiles.filter((file) => !destFiles.includes(file));
    const copies = copyFiles.map((file) => fs_1.promises.copyFile(path_1.default.resolve(`${srcPath}/${file}`), path_1.default.resolve(`${destPath}/${file}`)));
    await Promise.all(copies);
};
exports.copyFiles = copyFiles;
/**
 * writes a translation object to a file
 *
 * @param path path of the file
 * @param data the translation data to save
 *
 * @returns a promise that resolves when file writing is completed
 */
const writeTranslationToFile = async (path, data) => {
    const stringData = `${JSON.stringify(data, null, 2)}\n`;
    await fs_1.promises.writeFile(path, stringData, "utf8");
};
exports.writeTranslationToFile = writeTranslationToFile;
/**
 * merges the translations from one src file into one dest file
 *
 * @param srcPath directory to merge from
 * @param destPath directory to merge to
 * @param file the file to merge
 *
 * @returns a promise that resolves when merging is finished
 */
const buildMergeFile = (srcPath, destPath) => async (file) => {
    const destInfo = await fs_1.promises.readFile(`${destPath}/${file}`, "utf-8");
    const srcInfo = await fs_1.promises.readFile(`${srcPath}/${file}`, "utf-8");
    const destTranslations = JSON.parse(destInfo);
    const srcTranslations = JSON.parse(srcInfo);
    const data = (0, deepMerge_1.deepMerge)(destTranslations, srcTranslations, deepMerge_1.maxDepthTranslations);
    return { path: `${destPath}/${file}`, data: (0, sortMergedTranslations_1.sortMergedTranslations)(data) };
};
exports.buildMergeFile = buildMergeFile;
/**
 * merges all translation json files that currently exist
 *
 * @param srcPath directory to copy from
 * @param destPath directory to copy to
 * @param srcFiles the files to copy from
 * @param destFiles the files that currently exist in the destination directory
 *
 * @returns a promise that resolves when merging is finished
 */
const mergeFiles = async (srcPath, destPath, srcFiles, destFiles) => {
    const mergeFiles = srcFiles.filter((file) => destFiles.includes(file));
    const merges = mergeFiles.map((0, exports.buildMergeFile)(srcPath, destPath));
    const mergedData = await Promise.all(merges);
    const writingFiles = mergedData.map(({ path, data }) => (0, exports.writeTranslationToFile)(path, data));
    await Promise.all(writingFiles);
};
exports.mergeFiles = mergeFiles;
/**
 * handles syncing files from one directory to another
 *
 * @param srcPath directory to copy from
 * @param destPath directory to copy to
 * @param locales the list of languages to handle
 */
const syncDirectoryFiles = async (srcPath, destPath, locales) => await (0, handleError_1.addErrorHandler)(async () => {
    const syncRegex = (0, exports.getSyncRegex)(locales);
    await (0, fileUtils_1.createDirectory)(destPath);
    const srcFiles = await (0, fileUtils_1.globp)(syncRegex, { cwd: srcPath });
    const destFiles = await (0, fileUtils_1.globp)(syncRegex, { cwd: destPath });
    await (0, exports.mergeFiles)(srcPath, destPath, srcFiles, destFiles);
    await (0, exports.copyFiles)(srcPath, destPath, srcFiles, destFiles);
    return srcFiles;
}, (err) => `Could not sync files: "${err}"`)();
exports.syncDirectoryFiles = syncDirectoryFiles;
/**
 * cleans up non-english files by deleting files and keys that have no english
 * equivilant
 *
 * @param destPath directory to clean
 * @param mainFiles the list of file names from the main locale files in source directory
 * @param locales the list of languages to handle
 * @param mainLocal the locale to compare against
 */
const getDeletionSecondaryFiles = (destPath, mainFiles, locales, mainLocale) => async (file) => {
    const namespace = file.split(".")[0];
    const mainFileName = `${namespace}.${mainLocale}.braze.json`;
    if (!mainFiles.includes(mainFileName)) {
        const deletionFiles = await (0, fileUtils_1.globp)(`**/${namespace}.@(${locales.join("|")}).braze.json`, {
            cwd: destPath,
        });
        return deletionFiles;
    }
    return [];
};
exports.getDeletionSecondaryFiles = getDeletionSecondaryFiles;
/**
 * cleans up non-english files by deleting files and keys that have no english
 * equivilant
 *
 * @param mainFiles files to compare against
 * @param path directory to delete from
 * @param locales the list of languages to handle
 * @param mainLocal the locale to compare against
 */
const buildDeleteExtraFiles = (mainFiles, path, locales, mainLocale) => async (file) => {
    const namespace = file.split(".")[0];
    const mainFileName = `${namespace}.${mainLocale}.braze.json`;
    if (!mainFiles.includes(mainFileName)) {
        const deleteFiles = await (0, fileUtils_1.globp)(`**/${namespace}.@(${locales.join("|")}).braze.json`, {
            cwd: path,
        });
        await Promise.all(deleteFiles.map(async (file) => await fs_1.promises.rm(`${path}/${file}`)));
    }
};
exports.buildDeleteExtraFiles = buildDeleteExtraFiles;
/**
 * cleans up non-english files by deleting files and keys that have no english
 * equivilant
 *
 * @param mainFiles files to compare against
 * @param srcPath directory to compare against
 * @param destPath directory to clean
 * @param locales the list of languages to handle
 * @param mainLocal the locale to compare against
 */
const buildDeleteExtraKeys = (mainFiles, srcPath, destPath, locales, mainLocale) => async (file) => {
    const [namespace, currentLocale] = file.split(".");
    const mainFileName = `${namespace}.${mainLocale}.braze.json`;
    if (mainFiles.includes(mainFileName)) {
        const compareFiles = await (0, fileUtils_1.globp)(`**/${namespace}.@(${locales.join("|")}).braze.json`, {
            cwd: destPath,
        });
        await Promise.all(compareFiles.map(async (file) => {
            const destInfo = await fs_1.promises.readFile(`${destPath}/${file}`, "utf-8");
            const srcInfo = await fs_1.promises.readFile(`${srcPath}/${namespace}.${mainLocale}.braze.json`, "utf-8");
            const destTranslations = JSON.parse(destInfo);
            const srcTranslations = JSON.parse(srcInfo);
            const srcKeys = Object.keys(srcTranslations[mainLocale].braze[namespace]);
            const newTranslation = srcKeys.reduce((acc, key) => ({
                ...acc,
                [currentLocale]: {
                    ...acc[currentLocale],
                    braze: {
                        ...acc[currentLocale].braze,
                        [namespace]: {
                            ...acc[currentLocale].braze[namespace],
                            [key]: destTranslations[currentLocale].braze[namespace][key],
                        },
                    },
                },
            }), { [currentLocale]: { braze: { [namespace]: {} } } });
            await (0, exports.writeTranslationToFile)(`${destPath}/${file}`, newTranslation);
        }));
    }
};
exports.buildDeleteExtraKeys = buildDeleteExtraKeys;
/**
 * cleans up non-english files by deleting files and keys that have no english
 * equivilant
 *
 * @param srcPath directory to compare against
 * @param destPath directory to clean
 * @param locales the list of languages to handle
 * @param mainLocal the locale to compare against (default: english)
 */
const cleanLocaleFiles = async (srcPath, destPath, locales, mainLocale = "en") => await (0, handleError_1.addErrorHandler)(async () => {
    const mainRegex = (0, exports.getSyncRegex)([mainLocale]);
    const secondaryRegex = (0, exports.getSyncRegex)(locales);
    const mainFiles = await (0, fileUtils_1.globp)(mainRegex, { cwd: srcPath });
    const secondaryFiles = await (0, fileUtils_1.globp)(secondaryRegex, { cwd: destPath });
    // delete extra secondary locale files
    await Promise.all(secondaryFiles.map((0, exports.buildDeleteExtraFiles)(mainFiles, destPath, locales, mainLocale)));
    // delete extra secondary locale keys
    await Promise.all(secondaryFiles.map((0, exports.buildDeleteExtraKeys)(mainFiles, srcPath, destPath, locales, mainLocale)));
}, (err) => `Could not clean files for locales (${JSON.stringify(locales)}): "${err}"`)();
exports.cleanLocaleFiles = cleanLocaleFiles;
//# sourceMappingURL=syncUtils.js.map