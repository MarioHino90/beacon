"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.checkoutBranch = exports.cleanBranchesOnError = exports.cleanBranches = exports.resetCurrentBranch = exports.checkIfGitChanges = void 0;
const chalk_1 = require("chalk");
const execa_1 = __importDefault(require("execa"));
const handleError_1 = require("./handleError");
/**
 * checks if there were changes to the files in git
 *
 * @returns a promise that resolves to true if there were changes, false otherwise
 */
exports.checkIfGitChanges = (0, handleError_1.addErrorHandler)(async () => {
    const { stdout, stderr, exitCode } = await execa_1.default.command("git status -s");
    if (stderr || exitCode) {
        throw new Error(stderr);
    }
    return !!stdout;
}, (e) => `Could not check for changes: "${e}"`);
/**
 * resets current branch, clearing untracked files and resetting tracked ones
 *
 * @param repoPaths the string paths to the translations folders
 *
 * @returns a promise that resolves when reset is complete
 */
const resetCurrentBranch = async (repoPaths) => await (0, handleError_1.addErrorHandler)(async () => {
    const isDirty = await (0, exports.checkIfGitChanges)();
    if (isDirty) {
        const cleans = repoPaths.map(async (path) => await execa_1.default.command(`git clean -fdx ./${path}`));
        await Promise.all(cleans);
        await execa_1.default.command("git reset --hard");
    }
}, (err) => `Could not clear branch: "${err}"`)();
exports.resetCurrentBranch = resetCurrentBranch;
/**
 * cleans up local branches
 *
 * @param branchName the name of the branch to clean up
 * @param baseBranch the base branch to return to
 * @returns a promise that resolves when clean up is done
 */
const cleanBranches = async (branchName, baseBranch) => await (0, handleError_1.addErrorHandler)(async () => {
    await execa_1.default.command(`git checkout ${baseBranch}`);
    await execa_1.default.command(`git branch -D ${branchName}`);
}, (err) => `Could not clean branch: "${err}"`)();
exports.cleanBranches = cleanBranches;
/**
 * cleans and reset branches on error
 *
 * @param branchName the name of the branch to clean up
 * @param baseBranch the base branch to return to
 * @param repoPaths the string paths to the translations folders
 *
 * @returns a promise that resolves when clean up is done
 */
const cleanBranchesOnError = async (branchName, baseBranch, repoPaths) => {
    await (0, exports.resetCurrentBranch)(repoPaths);
    await (0, exports.cleanBranches)(branchName, baseBranch);
};
exports.cleanBranchesOnError = cleanBranchesOnError;
/**
 * checkouts a new branch based on main
 *
 * @param branchName the name of the branch to create
 * @param baseBranch the base branch to checkout
 */
const checkoutBranch = async (branchName, baseBranch) => await (0, handleError_1.addErrorHandler)(async () => {
    console.log((0, chalk_1.greenBright)(`Checking out current ${baseBranch} branch`));
    await execa_1.default.command(`git checkout ${baseBranch}`);
    await execa_1.default.command("git pull");
    console.log((0, chalk_1.greenBright)(`Creating new branch ${branchName}`));
    await execa_1.default.command(`git checkout -b ${branchName}`);
}, (err) => `Could not checkout branch ${branchName} based on ${baseBranch}: "${err}"`, async () => await (0, exports.cleanBranches)(branchName, baseBranch))();
exports.checkoutBranch = checkoutBranch;
//# sourceMappingURL=gitUtils.js.map