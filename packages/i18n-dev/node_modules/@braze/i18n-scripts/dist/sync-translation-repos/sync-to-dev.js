"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.syncToDevRepo = exports.addChanges = exports.checkForDevelopmentChanges = exports.checkIfDirty = exports.buildSyncFiles = exports.validateArgs = void 0;
const chalk_1 = require("chalk");
const execa_1 = __importDefault(require("execa"));
const path_1 = __importDefault(require("path"));
const process_1 = __importDefault(require("process"));
const config_node_1 = require("../config-node");
const utils_1 = require("./utils");
/**
 * validates that all of the configuration options are valid
 *
 * Exits process if checks fail
 *
 * @param config the current configuration options
 * @param getError function to get error string
 */
const validateArgs = async (config, getError) => {
    const { devRepo, translationRepo, translationRepoPaths } = config;
    const getValidationError = (err) => err.message;
    const getDevRepoValidationText = () => getError("devRepo", utils_1.ArgType.config);
    const devRepoCheck = (0, utils_1.addErrorHandler)(() => (0, utils_1.checkStringConfig)(devRepo, getDevRepoValidationText), getValidationError)();
    const getTranslationRepoValidationText = () => getError("translationRepo", utils_1.ArgType.cli);
    const translationRepoCheck = (0, utils_1.addErrorHandler)(() => (0, utils_1.checkStringConfig)(translationRepo, getTranslationRepoValidationText), getValidationError)();
    const getTranslationRepoPathsValidationText = () => getError("translationRepoPaths", utils_1.ArgType.config);
    const translationRepoPathsCheck = (0, utils_1.addErrorHandler)(() => 
    // this does not need the inside items verified because it's verified by
    // the config fetch if exists and CANNOT be passed as a command line argument
    (0, utils_1.checkArrayConfig)(translationRepoPaths, getTranslationRepoPathsValidationText), getValidationError)();
    await Promise.all([
        devRepoCheck,
        translationRepoCheck,
        translationRepoPathsCheck,
    ]);
};
exports.validateArgs = validateArgs;
/**
 * copies files from the dev directory to the translation directory
 *
 * @param translationRepo relative path to the translation repo
 * @param langs list of languages to sync
 * @param repoPath a link between a dev folder and a translation folder
 */
const buildSyncFiles = (translationRepo, langs) => async (repoPath) => {
    const { dev, translations } = repoPath;
    const translationsPath = path_1.default.resolve(`${translationRepo}/${translations}`);
    const devPath = path_1.default.resolve(dev);
    const files = await (0, utils_1.syncDirectoryFiles)(translationsPath, dev, langs);
    await (0, utils_1.cleanLocaleFiles)(devPath, devPath, langs);
    return files;
};
exports.buildSyncFiles = buildSyncFiles;
/**
 * check if there are any git changes and throw error if so
 */
const checkIfDirty = async () => {
    const isDirty = await (0, utils_1.checkIfGitChanges)();
    if (isDirty) {
        (0, utils_1.handleError)("Please stash or commit your changes in the Development repo");
    }
};
exports.checkIfDirty = checkIfDirty;
/**
 * check if the process of copying files caused changes - exits process if no
 * changes are found
 *
 * @param cleanTranslationBranches callback function to clean git repo on no changes found
 */
const checkForDevelopmentChanges = async (cleanTranslationBranches) => {
    // check if there were actually changes
    const hasChanges = await (0, utils_1.checkIfGitChanges)();
    if (hasChanges) {
        console.log((0, chalk_1.greenBright)("Files Copied To Development Repo!"));
    }
    else {
        console.log((0, chalk_1.yellowBright)("No Translation Changes Found. Exiting..."));
        await cleanTranslationBranches();
        process_1.default.exit();
    }
};
exports.checkForDevelopmentChanges = checkForDevelopmentChanges;
/**
 * Commits changes to git and pushes the branch
 *
 * @param cleanTranslationBranches callback to clean branches on error
 * @param branchName name of the current branch
 */
const addChanges = async (cleanTranslationBranches, branchName) => await (0, utils_1.addErrorHandler)(async () => {
    await execa_1.default.command("git add .");
    await (0, execa_1.default)("git", [
        "commit",
        "-m",
        `chore:\ sync\ translation\ files\ from\ translators\n`,
    ]);
    await execa_1.default.command(`git push --set-upstream origin ${branchName}`);
}, (err) => `Could not sync translation files: ${err}`, cleanTranslationBranches)();
exports.addChanges = addChanges;
/**
 * handles syncing translations from the development repo to the
 * translation repo
 *
 * NOTE: This handles multiple cases for keys. The expected behaviour is as follows:
 *
 * English Key removed in Dev -> Do not copy to Dev
 * English Key added in Dev -> Do not remove from Dev
 * English Value edited in Dev -> Do not overwrite in Dev
 * English Value, Translation Value the same in Translation  -> Do not overwrite
 * English Value Same as Translation Repo's, Translation Value different -> Overwrite Translation Value
 *
 * NOTE: This also handles multiple cases for files. The expected behaviour is as follows:
 *
 * File removed in Dev -> Do not copy to Dev
 * File added in Dev -> Do not remove from Dev
 * File exists in both Dev and Translation -> Merge keys in file as per above behaviour
 *
 * @param args the command line arguements
 * @param configPath the file path to the config file
 */
const syncToDevRepo = async (args, configPath) => {
    const config = (0, config_node_1.loadConfig)(configPath);
    const { translationRepo = "" } = args;
    const translationRepoPaths = config.get("translationRepoPaths");
    const devMainBranch = config.get("devMainBranch") || "main";
    const devRepo = config.get("devRepo") || "";
    const langs = config.get("devSyncLanguages");
    await (0, exports.validateArgs)({
        devRepo,
        translationRepo,
        translationRepoPaths,
    }, (0, utils_1.getConfigurationError)(configPath));
    // create branch and push
    const branchName = `translation-sync-${process_1.default.pid}`;
    await (0, exports.checkIfDirty)();
    await (0, utils_1.checkoutBranch)(branchName, devMainBranch);
    const cleanTranslationBranches = async () => await (0, utils_1.cleanBranches)(branchName, devMainBranch);
    // copy files to translation path
    const syncFiles = (0, exports.buildSyncFiles)(translationRepo, langs);
    const fileSyncs = translationRepoPaths.map((repoPath) => syncFiles(repoPath));
    await Promise.all(fileSyncs);
    // check if there were actually changes
    await (0, exports.checkForDevelopmentChanges)(cleanTranslationBranches);
    // if there were changes, commit and push them
    await (0, exports.addChanges)(async () => await (0, utils_1.cleanBranchesOnError)(branchName, devMainBranch, translationRepoPaths.map(({ dev }) => dev)), branchName);
    //  cleanup
    await cleanTranslationBranches();
    console.log((0, chalk_1.greenBright)(`Go to ${devRepo}/pull/new/${branchName} to open a new PR`));
};
exports.syncToDevRepo = syncToDevRepo;
exports.default = exports.syncToDevRepo;
//# sourceMappingURL=sync-to-dev.js.map