"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.saveConfig = exports.loadConfig = exports.validatePath = void 0;
/**
 * @fileoverview node-compatible version of config
 * this validates paths, which are useless in the frontend anyways
 * it also only loads from a configuration file path instead of a JSON Object
 */
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const convict_1 = __importDefault(require("convict"));
const config_shared_1 = require("./config-shared");
const currentConfig = {
    config: undefined,
};
const validatePath = (configPath) => (type) => (sources) => {
    const statsFunc = type === "path" ? "isDirectory" : "isFile";
    const error = `${type} must be an existing path that is a ${type === "path" ? "directory" : type}`;
    if (typeof sources !== "string") {
        throw new Error(`${type} must be a string`);
    }
    if (!fs_1.default.existsSync(path_1.default.resolve(path_1.default.dirname(configPath), sources))) {
        throw new Error(error);
    }
    const stats = fs_1.default.statSync(path_1.default.resolve(path_1.default.dirname(configPath), sources));
    if (!stats[statsFunc]()) {
        throw new Error(error);
    }
};
exports.validatePath = validatePath;
function loadConfig(configPath) {
    if (currentConfig.config) {
        return currentConfig.config;
    }
    if (typeof configPath !== "string") {
        throw new Error("loadConfig must be called with configuration path on the server, cannot be passed JSON");
    }
    const i18nConfig = (0, config_shared_1.getI18nConfig)(convict_1.default, (0, exports.validatePath)(configPath));
    if (configPath) {
        i18nConfig.loadFile(configPath);
    }
    else {
        i18nConfig.loadFile("./.i18nConfig.json");
    }
    i18nConfig.validate({ strict: true });
    currentConfig.config = i18nConfig;
    const get = i18nConfig.get.bind(i18nConfig);
    const newGet = (name) => {
        switch (name) {
            case "translationsPaths": {
                const paths = get(name);
                return paths.map((translationPath) => path_1.default.resolve(path_1.default.dirname(configPath), translationPath));
            }
            case "savePath":
            case "typescriptDefinitionPath":
            case "mergedTranslationsPath": {
                const translationPath = get(name);
                return path_1.default.resolve(path_1.default.dirname(configPath), translationPath);
            }
            case "translationRepoPaths": {
                const paths = get(name);
                return paths.map((repoPaths) => ({
                    ...repoPaths,
                    dev: path_1.default.resolve(path_1.default.dirname(configPath), repoPaths.dev),
                }));
            }
            default:
                return get(name);
        }
    };
    i18nConfig.get = newGet;
    return currentConfig.config;
}
exports.loadConfig = loadConfig;
/**
 * Save a new I18n configuration for use in future commands
 */
function saveConfig(values, configPath = "./.i18nConfig.json") {
    const i18nConfig = (0, config_shared_1.getI18nConfig)(convict_1.default, exports.validatePath);
    i18nConfig.load(values);
    i18nConfig.validate({ strict: true });
    const filePath = path_1.default.resolve(configPath);
    fs_1.default.writeFileSync(filePath, i18nConfig.toString() + "\n");
}
exports.saveConfig = saveConfig;
//# sourceMappingURL=config-node.js.map