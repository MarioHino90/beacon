"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getChangedJSONItems = exports.getFolder = exports.getDifferences = exports.getJSONItems = exports.getEnglishJSONFiles = exports.isEnglishJSON = void 0;
const execa_1 = __importDefault(require("execa"));
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const utils_1 = require("../sync-translation-repos/utils");
const utils_2 = require("./utils");
/**
 * indicates if a file is an english JSON file
 *
 * @param file the filename to check
 *
 * @returns whether or not the file is an english JSON file
 */
const isEnglishJSON = (file) => {
    var regexJsonFile = new RegExp("en\\.braze\\.json$", "i");
    return regexJsonFile.test(file);
};
exports.isEnglishJSON = isEnglishJSON;
/**
 * gets only the files that need to be processed for changes
 *
 * @param files all changed files
 *
 * @returns all changed files for processing
 */
const getEnglishJSONFiles = (files) => files.filter(exports.isEnglishJSON);
exports.getEnglishJSONFiles = getEnglishJSONFiles;
/**
 * gets translations from JSON file
 *
 * @param gitRoot the root of the git repo
 * @param files the files to get
 * @param locale the locale to fetch. Usually this should be "en"
 *
 * @returns a promise with the info from all JSON files
 */
const getJSONItems = async (gitRoot, files, locale = "en") => {
    const filePromises = files.map(async (file) => {
        const filename = `${gitRoot}/${file}`;
        if ((0, fs_1.existsSync)(filename)) {
            const infoJson = await fs_1.promises.readFile(filename, "utf-8");
            try {
                const info = JSON.parse(infoJson);
                return {
                    filename: file,
                    info: info[locale] ? info[locale].braze : info,
                };
            }
            catch (_a) {
                (0, utils_1.handleError)(`Could not parse translation data for file "${filename}"`);
            }
        }
        return { filename: file, info: {} };
    });
    return await Promise.all(filePromises);
};
exports.getJSONItems = getJSONItems;
/**
 * get differences between translations
 *
 * @param newTranslations the new data
 * @param oldTranslations the old data
 *
 * @return an object with only the new/changed translations
 */
const getDifferences = (newTranslations, oldTranslations) => Object.keys(newTranslations)
    .map((key) => {
    const newTrans = newTranslations[key];
    const oldTrans = oldTranslations[key];
    if (typeof newTrans === "object") {
        if (typeof oldTrans === "object") {
            const info = (0, exports.getDifferences)(newTrans, oldTrans);
            // this returns undefined if there are no difference instead of
            // wrapping it in a key, which will allow us to filter this out
            return info && { [key]: info };
        }
        return { [key]: newTrans };
    }
    // once we get here, we're only comparing strings - thanks to the above recursion
    if (newTrans !== oldTrans) {
        return { [key]: newTrans };
    }
    return undefined;
})
    .filter((trans) => trans !== undefined)
    .reduce((acc, cur) => ({ ...acc, ...cur }), {});
exports.getDifferences = getDifferences;
/**
 * get the folder of a particular file
 *
 * @param filename the file path
 *
 * @returns a string representation of the folder the file is in
 */
const getFolder = (filename) => path_1.default.dirname(filename);
exports.getFolder = getFolder;
/**
 * gets items that have changed in JSON files in an object, grouped by directory
 *
 * @param commit the hash of the commit to compare against
 * @param gitRoot the root of the git repo
 * @param files the filenames of the files to get changes from
 *
 * @returns the changed items as an object
 */
const getChangedJSONItems = async (commit, gitRoot, files) => {
    const jsonFiles = (0, exports.getEnglishJSONFiles)(files);
    await execa_1.default.command(`git checkout ${commit}`);
    const itemsOld = await (0, exports.getJSONItems)(gitRoot, jsonFiles);
    await execa_1.default.command("git checkout -");
    const items = await (0, exports.getJSONItems)(gitRoot, jsonFiles);
    return (jsonFiles
        // get changes from files
        .map((path) => {
        const file = items.find(({ filename }) => path === filename);
        const oldFile = itemsOld.find(({ filename }) => path === filename);
        if (!file || !oldFile) {
            return {
                filename: path,
                info: file && file.info,
            };
        }
        return {
            filename: path,
            info: (0, exports.getDifferences)(file.info, oldFile.info),
        };
    })
        // group info by directory instead of file
        .reduce((acc, cur) => {
        const dir = (0, exports.getFolder)(cur.filename);
        const prevInfo = acc.find(({ filename }) => dir === filename);
        const info = prevInfo ? { ...prevInfo.info, ...cur.info } : cur.info;
        return [
            ...acc.filter(({ filename }) => dir !== filename),
            { filename: dir, info },
        ];
    }, [])
        // remove empty items
        .filter(({ info }) => Object.keys(info).length > 0)
        // translate from array into object
        .reduce((acc, cur) => ({
        ...acc,
        [cur.filename]: { ...cur.info },
    }), {}));
};
exports.getChangedJSONItems = getChangedJSONItems;
/**
 * gets the commit hash to find changes against
 *
 * @returns the commit hash as a string
 */
const getCommitHash = (days) => (0, utils_1.addErrorHandler)(async () => {
    const { stdout } = await (0, execa_1.default)("git", [
        "log",
        '--pretty=format:"%H"',
        "-n",
        "1",
        `--before=\"${days}\ days\ ago\"`,
    ]);
    return stdout.split(`"`).length > 1 ? stdout.split(`"`)[1] : stdout;
}, (error) => error.message)();
/**
 * gets the list of files that have changed since a commit
 *
 * @param commit the hash of the commit to check against
 *
 * @returns a list of filenames of files that have changed
 */
const getChangedFiles = (commit) => (0, utils_1.addErrorHandler)(async () => {
    const { stdout: diffFiles } = await execa_1.default.command(`git diff --diff-filter=d --name-only ${commit}`);
    return diffFiles.split("\n");
}, (error) => error.message)();
/**
 * gets the root of the git repo
 *
 * @returns a string that is the file root of the git repo
 */
const getRootGit = (0, utils_1.addErrorHandler)(async () => {
    const { stdout } = await execa_1.default.command("git rev-parse --show-toplevel");
    return stdout;
}, (error) => error.message);
/**
 * writes the changed items to a file
 *
 * @param items the changed items to write to a file
 * @param locales the locales to make a temp file for
 *
 * @returns a promise that resolves when file is written to
 */
const writeToFile = async (items, locales) => {
    const info = JSON.stringify(items, null, 2);
    const writingLocalePromises = locales.map(async (locale) => await fs_1.promises.writeFile((0, utils_2.getTempFileName)(locale), info));
    await Promise.all(writingLocalePromises);
};
/**
 * checks if tmp files exist
 *
 * @returns true if files exist, false otherwise
 */
const checkIfTempFilesExist = async () => {
    const files = await (0, utils_1.globp)((0, utils_2.getTempFileName)("*"));
    return !!files.length;
};
/**
 * deletes all tmp files
 *
 * @returns a promise that resolves when the files are deleted
 */
const deleteTempFiles = async () => {
    const files = await (0, utils_1.globp)((0, utils_2.getTempFileName)("*"));
    const deletePromises = files.map(async (file) => await fs_1.promises.unlink(file));
    await Promise.all(deletePromises);
};
/**
 * gets all changes from before a specific date and moves them into a
 * temporary translator-friendly file
 */
const getTranslationChanges = (getChangedItems) => async ({ days = 7, locales = ["ja"], force, } = {}) => {
    // exit if the branch is not clean
    const isGitChanges = await (0, utils_1.checkIfGitChanges)();
    if (isGitChanges) {
        (0, utils_1.handleError)("Git branch must be clean to get changes to translation files");
    }
    // exit if there are no locales to translate to
    if (!locales.length) {
        (0, utils_1.handleError)("Must have locales to translate to");
    }
    // if there are tmp files, exit or delete if force
    const doTempFilesExist = await checkIfTempFilesExist();
    if (doTempFilesExist) {
        if (!force) {
            (0, utils_1.handleError)("Finish processing and remove existing temp files before getting more changes");
        }
        await deleteTempFiles();
    }
    const commit = await getCommitHash(days);
    const files = await getChangedFiles(commit);
    const rootGit = await getRootGit();
    const items = await getChangedItems(commit, rootGit, files);
    await writeToFile(items, locales);
};
exports.default = getTranslationChanges;
//# sourceMappingURL=get-translation-changes.js.map