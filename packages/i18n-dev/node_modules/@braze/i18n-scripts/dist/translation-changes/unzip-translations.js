"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createUpdateTranslationFile = exports.mergeTranslationData = exports.formatDataICU = exports.getTranslations = exports.getFilename = exports.formatTranslations = exports.checkIfDirty = void 0;
const execa_1 = __importDefault(require("execa"));
const fs_1 = require("fs");
const path_1 = __importDefault(require("path"));
const utils_1 = require("../sync-translation-repos/utils");
const utils_2 = require("./utils");
/**
 * deletes all tmp files
 *
 * @returns a promise that resolves when the files are deleted
 */
const deleteTempFiles = async () => {
    const files = await (0, utils_1.globp)((0, utils_2.getTempFileName)("*"));
    const deletePromises = files.map(async (file) => await fs_1.promises.unlink(file));
    await Promise.all(deletePromises);
};
/**
 * Commits changes to git and pushes the branch
 *
 * @param cleanTranslationBranches callback to clean branches on error
 * @param branchName name of the current branch
 */
const addChanges = async (cleanTranslationBranches, branchName) => await (0, utils_1.addErrorHandler)(async () => {
    await execa_1.default.command("git add .");
    await (0, execa_1.default)("git", [
        "commit",
        "-m",
        `Translate\ files\ from\ development\n`,
    ]);
    await execa_1.default.command(`git push --set-upstream origin ${branchName}`);
}, (err) => `Could not commit changes to ${branchName}: ${err}`, cleanTranslationBranches)();
/**
 * check if there are any git changes and throw error if so
 */
const checkIfDirty = async () => {
    const isDirty = await (0, utils_1.checkIfGitChanges)();
    if (isDirty) {
        (0, utils_1.handleError)("Please stash or commit your changes");
    }
};
exports.checkIfDirty = checkIfDirty;
/**
 * formats the data from the temporary files in a consumable format
 *
 * @param fileInfo the data from the files
 *
 * @returns the data from the files in a consumable format
 */
const formatTranslations = (fileInfo) => fileInfo.reduce((acc, { info, locale }) => {
    const directories = Object.keys(info);
    // go through each directory pull the namespaces to create the files
    return directories.reduce((dirAcc, dir) => {
        const dirInfo = info[dir];
        // sort the namespaces so they get processed alphabetically
        const namespaces = Object.keys(dirInfo).sort((a, b) => a.localeCompare(b));
        // create a filename + file data for each namespace
        return namespaces.reduce((nameAcc, namespace) => ({
            ...nameAcc,
            [`${dir}/${namespace}.${locale}.braze.json`]: {
                info: dirInfo[namespace],
                namespace,
                locale,
            },
        }), dirAcc);
    }, acc);
}, {});
exports.formatTranslations = formatTranslations;
/**
 * gets the path and locale of the temporary file
 *
 * @param file the filename
 *
 * @returns the full path of the file and the locale of the file
 */
const getFilename = (file) => {
    const base = path_1.default.basename(file).split(".");
    if (base.length < 3) {
        (0, utils_1.handleError)(`The filename of "${file}" is not properly constructed - it should be temp.<LOCALE>.json`);
    }
    return { file: path_1.default.resolve(file), locale: base[base.length - 2] };
};
exports.getFilename = getFilename;
/**
 * gets the data from a particular file
 *
 * @param filename - the file path and the locale of the file
 *
 * @returns the data from the file in a consumable format
 */
const getFileData = async ({ file, locale }) => {
    const fileInfo = await fs_1.promises.readFile(file, "utf-8");
    return { info: JSON.parse(fileInfo), locale: locale };
};
/**
 * gets the translations from the temp files
 *
 * @returns the translation data in a consumable format
 */
const getTranslations = async () => {
    const files = await (0, utils_1.globp)(`**/${(0, utils_2.getTempFileName)("*")}`);
    const filenames = files
        // Note: this removes any temp files in the node_modules folder explicitly
        .filter((file) => !file.match("node_modules/*"))
        .map(exports.getFilename);
    const filePromises = filenames.map(getFileData);
    const fileInfo = await Promise.all(filePromises);
    return (0, exports.formatTranslations)(fileInfo);
};
exports.getTranslations = getTranslations;
/**
 * formats data in the ICU format
 *
 * @param info the file data
 * @param locale the locale of the data
 * @param namespace the namespace for the data
 *
 * @returns the data in the ICU format
 */
const formatDataICU = ({ info, locale, namespace, }) => ({
    [locale]: {
        braze: {
            [namespace]: info,
        },
    },
});
exports.formatDataICU = formatDataICU;
/**
 * merges the new translation data with the previous translation data
 *
 * @param filename the path of the file
 * @param item the new translation data
 *
 * @returns the combinded data
 */
const mergeTranslationData = async (filename, item) => {
    const curInfoJson = await fs_1.promises.readFile(filename, "utf-8");
    const curInfo = JSON.parse(curInfoJson);
    return {
        ...(curInfo[item.locale].braze[item.namespace] || {}),
        ...item.info,
    };
};
exports.mergeTranslationData = mergeTranslationData;
/**
 * updates or creates a formal translation file
 *
 * @param items the data from the temporary files
 * @param filename the file name of the file to process
 *
 * @returns a promise that resolves when the file is updated/created
 */
const createUpdateTranslationFile = (items) => async (filename) => {
    const item = items[filename];
    const fullFile = path_1.default.resolve(filename);
    const translationsExist = (0, fs_1.existsSync)(fullFile);
    const data = await (translationsExist
        ? (0, exports.mergeTranslationData)(filename, item)
        : item.info);
    await (0, utils_1.writeTranslationToFile)(fullFile, (0, exports.formatDataICU)({ ...item, info: data }));
};
exports.createUpdateTranslationFile = createUpdateTranslationFile;
/**
 * pushes changes to the repo, ready for PR
 */
const pushChangesToRepo = async () => {
    const branchName = `translate-${Date.now()}`;
    await (0, utils_1.checkoutBranch)(branchName, "main");
    await addChanges(async () => (0, utils_1.cleanBranches)(branchName, "main"), branchName);
};
/**
 * gets all changes from before a specific date and moves them into a
 * temporary translator-friendly file
 */
const unzipTranslations = async ({ pushChanges = false, removeTempFiles = true, }) => {
    if (pushChanges) {
        // check if clean, because committing code to repo later
        await (0, exports.checkIfDirty)();
    }
    // get translations
    const itemsByDir = await (0, exports.getTranslations)();
    // create/merge translations
    const filenames = Object.keys(itemsByDir);
    const updateTranslationFile = (0, exports.createUpdateTranslationFile)(itemsByDir);
    const updatePromises = filenames.map(updateTranslationFile);
    await Promise.all(updatePromises);
    // optionally delete temp files (default: on)
    if (removeTempFiles) {
        await deleteTempFiles();
    }
    // optionally push changes to repo (default: off)
    if (pushChanges) {
        await pushChangesToRepo();
    }
};
exports.default = unzipTranslations;
//# sourceMappingURL=unzip-translations.js.map