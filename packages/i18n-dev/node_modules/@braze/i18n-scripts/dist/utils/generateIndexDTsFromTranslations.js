"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateIndexDTsFromTranslations = void 0;
const fs_1 = __importDefault(require("fs"));
const prettier_1 = __importDefault(require("prettier"));
const parseTypescriptParametersFromTranslation_1 = require("./parseTypescriptParametersFromTranslation");
// The line we look for in the translation type file for new entries
const startAuto = "// the next lines are auto-generated, do not modify";
const endAuto = "// DO NOT REMOVE THIS LINE - END Translation types";
const alpha = (a, b) => a.localeCompare(b);
/**
 * Given the merged English translations, generate typescript types and save them
 * @param englishTranslations the portion of translations inside { en: { braze: <here> } }
 * @param indexDTsPath path to the translation type, with the file name
 * @param interfaceName the name of the interface to use for translations
 */
async function generateIndexDTsFromTranslations(englishTranslations, indexDTsPath, interfaceName = "MessageValues") {
    const typescriptTypes = {};
    const errors = [];
    Object.keys(englishTranslations)
        .sort(alpha)
        .forEach((namespace) => {
        Object.keys(englishTranslations[namespace])
            .sort(alpha)
            .forEach((translationKey) => {
            try {
                typescriptTypes[namespace] = typescriptTypes[namespace] || {};
                typescriptTypes[namespace][translationKey] =
                    (0, parseTypescriptParametersFromTranslation_1.parseTypescriptParametersFromTranslation)(englishTranslations[namespace][translationKey]);
            }
            catch (e) {
                errors.push(`Invalid translation for namespace "${namespace}", key "${translationKey}": ${e}`);
            }
        });
    });
    if (errors.length) {
        return Promise.reject(new Error(errors.join("\n")));
    }
    // read in the existing file
    const indexTs = await fs_1.default.promises.readFile(indexDTsPath, {
        encoding: "utf8",
        flag: "r",
    });
    const internalDefinitions = "  " +
        prettier_1.default
            .format(`export interface ${interfaceName} extends Resources\n${JSON.stringify(typescriptTypes, null, 2)
            .replace(/: "never"/g, ": never")
            .replace(/: "string"/g, ": string")
            .replace(/: "number"/g, ": number")
            .replace(/: "Date"/g, ": Date")}\n`, {
            parser: "typescript",
        })
            .replace(/: '("[^']+")'/g, ": $1");
    const autoPos = indexTs.indexOf(startAuto) + startAuto.length + 1;
    const endPos = indexTs.indexOf(endAuto);
    const startIndexTs = indexTs.slice(0, autoPos);
    const restOfIndexTs = indexTs.slice(endPos);
    // insert the index.d.ts entries
    const newIndexTs = prettier_1.default.format(`${startIndexTs}${internalDefinitions}${restOfIndexTs}`, { parser: "typescript" });
    return await fs_1.default.promises.writeFile(indexDTsPath, newIndexTs);
}
exports.generateIndexDTsFromTranslations = generateIndexDTsFromTranslations;
//# sourceMappingURL=generateIndexDTsFromTranslations.js.map