"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeNamespacedTranslations = void 0;
const fs_1 = __importDefault(require("fs"));
const deepMerge_1 = require("./deepMerge");
/**
 * Using the output of `getTranslationMetaData`, merge the newly created missing translations into each namespaced translation file.
 *
 * For namespace `account-settings`, this function will retrieve any existing translations from `account-settings.en.braze.json`
 * and `account-settings.jp.braze.json` (one for each locale Braze uses), and then merge in the missing translations, and write
 * out the new translation files.
 * @param locales
 * @param newNamespacedTranslations
 */
function mergeNamespacedTranslations(locales, newNamespacedTranslations) {
    const { getFilename, namespace, translations } = newNamespacedTranslations;
    return locales.map((locale) => {
        const path = getFilename(locale);
        let existingTranslations;
        try {
            existingTranslations = fs_1.default.readFileSync(path, {
                encoding: "utf8",
                flag: "r",
            });
        }
        catch (_) {
            // this is a new namespace, start from scratch
            existingTranslations = "{}";
        }
        /** @type {import("../i18n").Translation} */
        const newValue = {
            [locale]: { braze: { [namespace]: translations } },
        };
        return [
            path,
            namespace,
            (0, deepMerge_1.deepMerge)(JSON.parse(existingTranslations), newValue, deepMerge_1.maxDepthTranslations),
        ];
    });
}
exports.mergeNamespacedTranslations = mergeNamespacedTranslations;
//# sourceMappingURL=mergeNamespacedTranslations.js.map