"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateTranslations = void 0;
const fs_1 = __importDefault(require("fs"));
const mergeNamespacedTranslations_1 = require("./mergeNamespacedTranslations");
const getTranslationMetaData_1 = require("./getTranslationMetaData");
const deepMerge_1 = require("./deepMerge");
const getNamespacedTranslation_1 = require("./getNamespacedTranslation");
/**
 * Transform an array of JSON translation dotted.key => value pairs into an object with each sub-key as a key to an indexed object
 */
function getJsonEntries(entries) {
    return Object.entries(entries).reduce((all, [key, newEntry]) => (0, deepMerge_1.deepMerge)(all, (0, getNamespacedTranslation_1.getNamespacedTranslation)(key, newEntry), deepMerge_1.maxDepthTranslations), {});
}
/**
 * Using the output of `getNamespaceTranslations`, write out the missing translations into each locale file.
 *
 * For namespace `account-settings`, this function will retrieve any existing translations from `account-settings.en.braze.json`
 * and `account-settings.jp.braze.json` (one for each locale Braze uses), and then merge in the missing translations, and write
 * out the new translation files.
 */
function mergeAndSaveTranslations(locales, newNamespacedTranslations) {
    (0, mergeNamespacedTranslations_1.mergeNamespacedTranslations)(locales, newNamespacedTranslations).forEach(([path, , contents]) => {
        fs_1.default.writeFileSync(path, JSON.stringify(contents, null, 2));
    });
}
/**
 * Given the output of the client-side missing translation handler for i18next, update translation files
 * and the translation type file to include the missing translations.
 * @param locales the locales supported
 * @param entries the missing/changed translations to update
 * @param localesPath full path to the directory locale json files are stored in
 */
const updateTranslations = (locales, entries, localesPath) => {
    // update the translation files
    const namespacedTranslations = (0, getTranslationMetaData_1.getTranslationMetaData)(getJsonEntries(entries), localesPath);
    namespacedTranslations.forEach((data) => mergeAndSaveTranslations(locales, data));
};
exports.updateTranslations = updateTranslations;
//# sourceMappingURL=updateTranslations.js.map